"""ReadOnlyDB â€” SELECT-only database wrapper for analysis modules.

Wraps an aiosqlite connection and blocks all write operations.
Analysis modules receive this instead of the raw Database object.
"""

from __future__ import annotations

import re

import aiosqlite
import structlog

log = structlog.get_logger()

# Patterns that indicate a write operation
_WRITE_PATTERNS = re.compile(
    r"^\s*(INSERT|UPDATE|DELETE|DROP|ALTER|CREATE|REPLACE|ATTACH|DETACH|REINDEX|VACUUM|PRAGMA\s+\w+\s*=)",
    re.IGNORECASE,
)


class ReadOnlyDB:
    """Read-only database wrapper. Only allows SELECT queries."""

    def __init__(self, conn: aiosqlite.Connection):
        self._conn = conn

    def _check_readonly(self, sql: str) -> None:
        """Raise ValueError if the SQL is not a read-only query."""
        # Check each statement to prevent multi-statement bypass (e.g. "SELECT 1; DROP TABLE")
        for statement in sql.split(";"):
            statement = statement.strip()
            if statement and _WRITE_PATTERNS.match(statement):
                raise ValueError(f"Write operation blocked in read-only mode: {statement[:80]}")

    async def execute(self, sql: str, params: tuple = ()) -> aiosqlite.Cursor:
        """Execute a read-only SQL query."""
        self._check_readonly(sql)
        return await self._conn.execute(sql, params)

    async def fetchone(self, sql: str, params: tuple = ()) -> dict | None:
        """Execute query and return one row as dict, or None."""
        self._check_readonly(sql)
        cursor = await self._conn.execute(sql, params)
        row = await cursor.fetchone()
        return dict(row) if row else None

    async def fetchall(self, sql: str, params: tuple = ()) -> list[dict]:
        """Execute query and return all rows as list of dicts."""
        self._check_readonly(sql)
        cursor = await self._conn.execute(sql, params)
        rows = await cursor.fetchall()
        return [dict(r) for r in rows]


def get_schema_description() -> dict:
    """Return a dict describing all tables, columns, and their purposes.

    This is passed to analysis modules so they know what data is available.
    """
    return {
        "candles": {
            "description": "OHLCV market data, tiered by timeframe",
            "columns": {
                "symbol": "Trading pair (e.g., BTC/USD)",
                "timeframe": "'5m', '1h', or '1d'",
                "timestamp": "ISO 8601 datetime",
                "open": "Opening price", "high": "High price",
                "low": "Low price", "close": "Closing price",
                "volume": "Trade volume",
            },
        },
        "trades": {
            "description": "Completed trades with P&L",
            "columns": {
                "symbol": "Trading pair",
                "side": "'long' or 'short'",
                "qty": "Quantity traded",
                "entry_price": "Entry fill price",
                "exit_price": "Exit fill price",
                "pnl": "Realized profit/loss (USD)",
                "pnl_pct": "P&L as percentage of entry",
                "fees": "Fees paid (USD)",
                "intent": "DAY, SWING, or POSITION",
                "strategy_version": "Strategy version that generated this trade",
                "strategy_regime": "What the strategy thought the regime was (not truth)",
                "opened_at": "Position open time",
                "closed_at": "Position close time",
            },
        },
        "signals": {
            "description": "All signals generated by the strategy",
            "columns": {
                "symbol": "Trading pair",
                "action": "BUY, SELL, or CLOSE",
                "size_pct": "Position size as fraction of portfolio",
                "confidence": "Strategy confidence 0.0-1.0",
                "intent": "DAY, SWING, or POSITION",
                "reasoning": "Strategy's reasoning text",
                "strategy_regime": "What the strategy thought the regime was",
                "acted_on": "1 if trade was executed, 0 if rejected",
                "rejected_reason": "Why signal was rejected (if applicable)",
                "created_at": "Signal generation time",
            },
        },
        "scan_results": {
            "description": "Raw indicator values from every scan (truth) + strategy regime (interpretation)",
            "columns": {
                "timestamp": "Scan time",
                "symbol": "Trading pair",
                "price": "Current price at scan time (truth)",
                "ema_fast": "Fast EMA value (truth)",
                "ema_slow": "Slow EMA value (truth)",
                "rsi": "RSI value (truth)",
                "volume_ratio": "Volume relative to average (truth)",
                "spread": "Bid-ask spread (truth)",
                "strategy_regime": "Strategy's regime classification (interpretation, not truth)",
                "signal_generated": "1 if a signal was generated this scan",
                "signal_action": "BUY/SELL/CLOSE if signal generated",
                "signal_confidence": "Signal confidence if generated",
            },
        },
        "daily_performance": {
            "description": "Daily portfolio snapshots",
            "columns": {
                "date": "Date (YYYY-MM-DD)",
                "portfolio_value": "Total portfolio value",
                "cash": "Cash balance",
                "total_trades": "Trades completed that day",
                "wins": "Winning trades", "losses": "Losing trades",
                "gross_pnl": "P&L before fees", "net_pnl": "P&L after fees",
                "fees_total": "Total fees that day",
                "win_rate": "Win rate that day",
                "expectancy": "Expectancy that day",
                "strategy_version": "Active strategy version",
            },
        },
        "positions": {
            "description": "Currently open positions",
            "columns": {
                "symbol": "Trading pair",
                "side": "'long' or 'short'",
                "qty": "Position size",
                "avg_entry": "Average entry price",
                "current_price": "Last known price",
                "stop_loss": "Stop-loss price",
                "take_profit": "Take-profit price",
                "intent": "DAY, SWING, or POSITION",
            },
        },
        "fee_schedule": {
            "description": "Fee schedule history from Kraken",
            "columns": {
                "maker_fee_pct": "Maker fee percentage",
                "taker_fee_pct": "Taker fee percentage",
                "checked_at": "When fees were last checked",
            },
        },
        "strategy_versions": {
            "description": "Strategy version history",
            "columns": {
                "version": "Version identifier",
                "parent_version": "Previous version",
                "risk_tier": "1=tweak, 2=restructure, 3=overhaul",
                "description": "What changed",
                "deployed_at": "When deployed",
                "retired_at": "When replaced",
            },
        },
    }
